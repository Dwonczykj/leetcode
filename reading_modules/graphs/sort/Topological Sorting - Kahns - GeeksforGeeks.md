[https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/](https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/)

# Kahn’s algorithm for Topological Sorting

Last Updated : 11 Jul, 2024

Improve

Summarize

Suggest changes

Post a comment

214 Likes

Like

Save

Share

Report

Given a ****Directed Acyclic Graph**** having ****V**** vertices and ****E**** edges, your task is to find any ****Topological Sorted order**** of the graph.

<u><b><strong class="GFGEditorTheme__textUnderline">Topological Sorted order</strong></b></u>: It is a linear ordering of vertices such that for every directed edge ****u -> v****, where vertex ****u**** comes before ****v i****n the ordering.

****Example****:

> ****Input:**** V=6 , E = {{2,3}, {3,1}, {4,0}, {4,1}, {5,0}, {5,2}}  
> ![](https://media.geeksforgeeks.org/wp-content/uploads/20200529233009/Untitled-Diagram-337.png)
> 
> ****Output:**** 4 5 2 0 3 1  
> ****Explanation****: In the above output, each dependent vertex is printed after the vertices it depends upon.
> 
> ****Input****: V=5 , E={{0,1}, {1,2}, {3,2}, {3,4}}  
> ![](https://media.geeksforgeeks.org/wp-content/uploads/20200529233105/Untitled-Diagram-256.png)
> 
> ****Output****: 0 3 4 1 2  
> ****Explanation****: In the above output, each dependent vertex is printed after the vertices it depends upon.

## Kahn’s Algorithm for Topological Sorting:

> ****Kahn’s Algorithm**** for Topological Sorting is a method used to order the vertices of a directed graph in a linear order such that for every directed edge from vertex ****A**** to vertex ****B****, ****A**** comes before ****B**** in the order. The algorithm works by repeatedly finding vertices with no incoming edges, removing them from the graph, and updating the incoming edges of the remaining vertices. This process continues until all vertices have been ordered.

### ****Algorithm:****

-   Add all nodes with in-degree ****0**** to a queue.
-   While the queue is not empty:
    -   Remove a node from the queue.
    -   For each outgoing edge from the removed node, decrement the in-degree of the destination node by ****1****.
    -   If the in-degree of a destination node becomes ****0****, add it to the queue.
-   If the queue is empty and there are still nodes in the graph, the graph contains a cycle and cannot be topologically sorted.
-   The nodes in the queue represent the topological ordering of the graph.

### ****How to find the in-degree of each node?**** 

> To find the ****in-degree**** of each node by initially calculating the number of incoming edges to each node. Iterate through all the edges in the graph and ****increment**** the ****in-degree**** of the ****destination**** ****node**** for each edge. This way, you can determine the in-degree of each node before starting the sorting process.

Below is the implementation of the above algorithm. 

C++` ``` <span></span><span class="c1">// Including necessary header file</span> <span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;bits/stdc++.h&gt;</span> <span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>  <span class="c1">// Function to return list containing vertices in</span> <span class="c1">// Topological order.</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">topologicalSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span> <span class="w">                            </span><span class="kt">int</span><span class="w"> </span><span class="n">V</span><span class="p">)</span> <span class="p">{</span> <span class="w">    </span><span class="c1">// Vector to store indegree of each vertex</span> <span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">indegree</span><span class="p">(</span><span class="n">V</span><span class="p">);</span> <span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="n">indegree</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="w">        </span><span class="p">}</span> <span class="w">    </span><span class="p">}</span>  <span class="w">    </span><span class="c1">// Queue to store vertices with indegree 0</span> <span class="w">    </span><span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">q</span><span class="p">;</span> <span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="w">        </span><span class="p">}</span> <span class="w">    </span><span class="p">}</span> <span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">;</span> <span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span> <span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="w">        </span><span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="w">        </span><span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>  <span class="w">        </span><span class="c1">// Decrease indegree of adjacent vertices as the</span> <span class="w">        </span><span class="c1">// current node is in topological order</span> <span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">node</span><span class="p">])</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="n">indegree</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>  <span class="w">            </span><span class="c1">// If indegree becomes 0, push it to the queue</span> <span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">indegree</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span> <span class="w">                </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">it</span><span class="p">);</span> <span class="w">        </span><span class="p">}</span> <span class="w">    </span><span class="p">}</span>  <span class="w">    </span><span class="c1">// Check for cycle</span> <span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">V</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Graph contains cycle!"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span> <span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">{};</span> <span class="w">    </span><span class="p">}</span>  <span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span> <span class="p">}</span>  <span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span> <span class="p">{</span>  <span class="w">    </span><span class="c1">// Number of nodes</span> <span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>  <span class="w">    </span><span class="c1">// Edges</span> <span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">edges</span> <span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">},</span> <span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">};</span>  <span class="w">    </span><span class="c1">// Graph represented as an adjacency list</span> <span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">adj</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>  <span class="w">    </span><span class="c1">// Constructing adjacency list</span> <span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">edges</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">        </span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="w">    </span><span class="p">}</span>  <span class="w">    </span><span class="c1">// Performing topological sort</span> <span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Topological sorting of the graph: "</span><span class="p">;</span> <span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">topologicalSort</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>  <span class="w">    </span><span class="c1">// Displaying result</span> <span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" "</span><span class="p">;</span> <span class="w">    </span><span class="p">}</span>  <span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span> <span class="p">}</span> ``` `
Java` ``` <span></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.*</span><span class="p">;</span>  <span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Main</span><span class="w"> </span><span class="p">{</span>  <span class="w">    </span><span class="c1">// Function to return array containing vertices in</span> <span class="w">    </span><span class="c1">// Topological order.</span> <span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="nf">topologicalSort</span><span class="p">(</span> <span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">V</span><span class="p">)</span> <span class="w">    </span><span class="p">{</span> <span class="w">        </span><span class="c1">// Array to store indegree of each vertex</span> <span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">indegree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">V</span><span class="o">]</span><span class="p">;</span> <span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">adj</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="p">{</span> <span class="w">                </span><span class="n">indegree</span><span class="o">[</span><span class="n">it</span><span class="o">]++</span><span class="p">;</span> <span class="w">            </span><span class="p">}</span> <span class="w">        </span><span class="p">}</span>  <span class="w">        </span><span class="c1">// Queue to store vertices with indegree 0</span> <span class="w">        </span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedList</span><span class="o">&lt;&gt;</span><span class="p">();</span> <span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">indegree</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">                </span><span class="n">q</span><span class="p">.</span><span class="na">offer</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="w">            </span><span class="p">}</span> <span class="w">        </span><span class="p">}</span>  <span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">V</span><span class="o">]</span><span class="p">;</span> <span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span> <span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="na">poll</span><span class="p">();</span> <span class="w">            </span><span class="n">result</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">;</span>  <span class="w">            </span><span class="c1">// Decrease indegree of adjacent vertices as the</span> <span class="w">            </span><span class="c1">// current node is in topological order</span> <span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">adj</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">node</span><span class="p">))</span><span class="w"> </span><span class="p">{</span> <span class="w">                </span><span class="n">indegree</span><span class="o">[</span><span class="n">it</span><span class="o">]--</span><span class="p">;</span>  <span class="w">                </span><span class="c1">// If indegree becomes 0, push it to the</span> <span class="w">                </span><span class="c1">// queue</span> <span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">indegree</span><span class="o">[</span><span class="n">it</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">                    </span><span class="n">q</span><span class="p">.</span><span class="na">offer</span><span class="p">(</span><span class="n">it</span><span class="p">);</span> <span class="w">                </span><span class="p">}</span> <span class="w">            </span><span class="p">}</span> <span class="w">        </span><span class="p">}</span>  <span class="w">        </span><span class="c1">// Check for cycle</span> <span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">V</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">"Graph contains cycle!"</span><span class="p">);</span> <span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span> <span class="w">        </span><span class="p">}</span>  <span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span> <span class="w">    </span><span class="p">}</span>  <span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span> <span class="w">    </span><span class="p">{</span> <span class="w">        </span><span class="c1">// Number of nodes</span> <span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>  <span class="w">        </span><span class="c1">// Edges</span> <span class="w">        </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">edges</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">},</span> <span class="w">                          </span><span class="p">{</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">};</span>  <span class="w">        </span><span class="c1">// Graph represented as an adjacency list</span> <span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">adj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span> <span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="n">adj</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">());</span> <span class="w">        </span><span class="p">}</span>  <span class="w">        </span><span class="c1">// Constructing adjacency list</span> <span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">edges</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="n">adj</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">edge</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">).</span><span class="na">add</span><span class="p">(</span><span class="n">edge</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">);</span> <span class="w">        </span><span class="p">}</span>  <span class="w">        </span><span class="c1">// Performing topological sort</span> <span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span> <span class="w">            </span><span class="s">"Topological sorting of the graph: "</span><span class="p">);</span> <span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">topologicalSort</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>  <span class="w">        </span><span class="c1">// Displaying result</span> <span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">print</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">" "</span><span class="p">);</span> <span class="w">        </span><span class="p">}</span> <span class="w">    </span><span class="p">}</span> <span class="p">}</span> ``` `
Python` ``` <span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>  <span class="c1"># Function to return list containing vertices in Topological order.</span>   <span class="k">def</span> <span class="nf">topological_sort</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>     <span class="c1"># Vector to store indegree of each vertex</span>     <span class="n">indegree</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">V</span>     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">):</span>         <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>             <span class="n">indegree</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>      <span class="c1"># Queue to store vertices with indegree 0</span>     <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">):</span>         <span class="k">if</span> <span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>             <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>     <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>     <span class="k">while</span> <span class="n">q</span><span class="p">:</span>         <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>         <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>         <span class="c1"># Decrease indegree of adjacent vertices as the current node is in topological order</span>         <span class="k">for</span> <span class="n">adjacent</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>             <span class="n">indegree</span><span class="p">[</span><span class="n">adjacent</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>             <span class="c1"># If indegree becomes 0, push it to the queue</span>             <span class="k">if</span> <span class="n">indegree</span><span class="p">[</span><span class="n">adjacent</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>                 <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adjacent</span><span class="p">)</span>      <span class="c1"># Check for cycle</span>     <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">!=</span> <span class="n">V</span><span class="p">:</span>         <span class="nb">print</span><span class="p">(</span><span class="s2">"Graph contains cycle!"</span><span class="p">)</span>         <span class="k">return</span> <span class="p">[]</span>     <span class="k">return</span> <span class="n">result</span>   <span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>     <span class="n">n</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># Number of nodes</span>      <span class="c1"># Edges</span>     <span class="n">edges</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>      <span class="c1"># Graph represented as an adjacency list</span>     <span class="n">adj</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>      <span class="c1"># Constructing adjacency list</span>     <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>         <span class="n">adj</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>      <span class="c1"># Performing topological sort</span>     <span class="nb">print</span><span class="p">(</span><span class="s2">"Topological sorting of the graph:"</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">" "</span><span class="p">)</span>     <span class="n">result</span> <span class="o">=</span> <span class="n">topological_sort</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>      <span class="c1"># Displaying result</span>     <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>         <span class="nb">print</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">" "</span><span class="p">)</span> ``` `
C#` ``` <span></span><span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span> <span class="k">using</span><span class="w"> </span><span class="nn">System.Collections.Generic</span><span class="p">;</span>  <span class="k">class</span><span class="w"> </span><span class="nc">Program</span><span class="w"> </span><span class="p">{</span> <span class="w">    </span><span class="c1">// Function to return list containing vertices in</span> <span class="w">    </span><span class="c1">// Topological order.</span> <span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TopologicalSort</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span> <span class="w">                                     </span><span class="kt">int</span><span class="w"> </span><span class="n">V</span><span class="p">)</span> <span class="w">    </span><span class="p">{</span> <span class="w">        </span><span class="c1">// Vector to store indegree of each vertex</span> <span class="w">        </span><span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">indegree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">V</span><span class="p">];</span> <span class="w">        </span><span class="k">foreach</span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">adj</span><span class="p">)</span> <span class="w">        </span><span class="p">{</span> <span class="w">            </span><span class="k">foreach</span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">list</span><span class="p">)</span> <span class="w">            </span><span class="p">{</span> <span class="w">                </span><span class="n">indegree</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="w">            </span><span class="p">}</span> <span class="w">        </span><span class="p">}</span>  <span class="w">        </span><span class="c1">// Queue to store vertices with indegree 0</span> <span class="w">        </span><span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span> <span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">                </span><span class="n">q</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="w">            </span><span class="p">}</span> <span class="w">        </span><span class="p">}</span> <span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span> <span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">Count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span> <span class="w">            </span><span class="n">result</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">node</span><span class="p">);</span> <span class="w">            </span><span class="c1">// Decrease indegree of adjacent vertices as the</span> <span class="w">            </span><span class="c1">// current node is in topological order</span> <span class="w">            </span><span class="k">foreach</span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">adjacent</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="w">            </span><span class="p">{</span> <span class="w">                </span><span class="n">indegree</span><span class="p">[</span><span class="n">adjacent</span><span class="p">]</span><span class="o">--</span><span class="p">;</span> <span class="w">                </span><span class="c1">// If indegree becomes 0, push it to the</span> <span class="w">                </span><span class="c1">// queue</span> <span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">indegree</span><span class="p">[</span><span class="n">adjacent</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="p">)</span> <span class="w">                    </span><span class="n">q</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">adjacent</span><span class="p">);</span> <span class="w">            </span><span class="p">}</span> <span class="w">        </span><span class="p">}</span>  <span class="w">        </span><span class="c1">// Check for cycle</span> <span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">Count</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">V</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"Graph contains cycle!"</span><span class="p">);</span> <span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span> <span class="w">        </span><span class="p">}</span> <span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span> <span class="w">    </span><span class="p">}</span>  <span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span> <span class="w">    </span><span class="p">{</span> <span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">6</span><span class="p">;</span><span class="w"> </span><span class="c1">// Number of nodes</span>  <span class="w">        </span><span class="c1">// Edges</span> <span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">edges</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">{</span> <span class="w">            </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">},</span> <span class="w">            </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="p">},</span> <span class="w">              </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="w"> </span><span class="m">5</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="w"> </span><span class="m">5</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">}</span> <span class="w">        </span><span class="p">};</span>  <span class="w">        </span><span class="c1">// Graph represented as an adjacency list</span> <span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">adj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">();</span> <span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="n">adj</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span> <span class="w">        </span><span class="p">}</span> <span class="w">        </span><span class="c1">// Constructing adjacency list</span> <span class="w">        </span><span class="k">foreach</span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">edges</span><span class="p">)</span> <span class="w">        </span><span class="p">{</span> <span class="w">            </span><span class="n">adj</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="m">0</span><span class="p">]].</span><span class="n">Add</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="m">1</span><span class="p">]);</span> <span class="w">        </span><span class="p">}</span>  <span class="w">        </span><span class="c1">// Performing topological sort</span> <span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">"Topological sorting of the graph: "</span><span class="p">);</span> <span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TopologicalSort</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>  <span class="w">        </span><span class="c1">// Displaying result</span> <span class="w">        </span><span class="k">foreach</span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">result</span><span class="p">)</span> <span class="w">        </span><span class="p">{</span> <span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">vertex</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">" "</span><span class="p">);</span> <span class="w">        </span><span class="p">}</span> <span class="w">    </span><span class="p">}</span> <span class="p">}</span> ``` `
JavaScript` ``` <span></span><span class="c1">// Function to return list containing vertices in Topological order.</span> <span class="kd">function</span><span class="w"> </span><span class="nx">topologicalSort</span><span class="p">(</span><span class="nx">adj</span><span class="p">,</span><span class="w"> </span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">    </span><span class="c1">// Vector to store indegree of each vertex</span> <span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">indegree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Array</span><span class="p">(</span><span class="nx">V</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span> <span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">V</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">vertex</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">adj</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="nx">indegree</span><span class="p">[</span><span class="nx">vertex</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="w">        </span><span class="p">}</span> <span class="w">    </span><span class="p">}</span>  <span class="w">    </span><span class="c1">// Queue to store vertices with indegree 0</span> <span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span> <span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">V</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">indegree</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="w">        </span><span class="p">}</span> <span class="w">    </span><span class="p">}</span> <span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span> <span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">q</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span> <span class="w">        </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span> <span class="w">        </span><span class="c1">// Decrease indegree of adjacent vertices as the current node is in topological order</span> <span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">adjacent</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">adj</span><span class="p">[</span><span class="nx">node</span><span class="p">])</span><span class="w"> </span><span class="p">{</span> <span class="w">            </span><span class="nx">indegree</span><span class="p">[</span><span class="nx">adjacent</span><span class="p">]</span><span class="o">--</span><span class="p">;</span> <span class="w">            </span><span class="c1">// If indegree becomes 0, push it to the queue</span> <span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">indegree</span><span class="p">[</span><span class="nx">adjacent</span><span class="p">]</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">adjacent</span><span class="p">);</span> <span class="w">        </span><span class="p">}</span> <span class="w">    </span><span class="p">}</span> <span class="w">    </span> <span class="w">    </span><span class="c1">// Check for cycle</span> <span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">!==</span><span class="w"> </span><span class="nx">V</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">        </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Graph contains cycle!"</span><span class="p">);</span> <span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">[];</span> <span class="w">    </span><span class="p">}</span> <span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">result</span><span class="p">;</span> <span class="p">}</span>  <span class="kd">const</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">6</span><span class="p">;</span><span class="w"> </span><span class="c1">// Number of nodes</span>  <span class="c1">// Edges</span> <span class="kd">const</span><span class="w"> </span><span class="nx">edges</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">4</span><span class="p">,</span><span class="w"> </span><span class="mf">5</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">]];</span>  <span class="c1">// Graph represented as an adjacency list</span> <span class="kd">const</span><span class="w"> </span><span class="nx">adj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Array</span><span class="p">.</span><span class="kr">from</span><span class="p">({</span><span class="w"> </span><span class="nx">length</span><span class="o">:</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">[]);</span>  <span class="c1">// Constructing adjacency list</span> <span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">edge</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">edges</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">    </span><span class="nx">adj</span><span class="p">[</span><span class="nx">edge</span><span class="p">[</span><span class="mf">0</span><span class="p">]].</span><span class="nx">push</span><span class="p">(</span><span class="nx">edge</span><span class="p">[</span><span class="mf">1</span><span class="p">]);</span> <span class="p">}</span>  <span class="c1">// Performing topological sort</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Topological sorting of the graph: "</span><span class="p">);</span> <span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">topologicalSort</span><span class="p">(</span><span class="nx">adj</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">);</span>  <span class="c1">// Displaying result</span> <span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">vertex</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span> <span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">vertex</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">" "</span><span class="p">);</span> <span class="p">}</span> ``` `

  
**Output**

```
Topological sorting of the graph: 0 4 5 1 2 3 
```

****Working of the above algorithm:****

![Kahn's-Algorithm-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)![Kahn's-Algorithm-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)

![Kahn's-Algorithm-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)![Kahn's-Algorithm-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)

![Kahn's-Algorithm-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)![Kahn's-Algorithm-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)

![Kahn's-Algorithm-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)![Kahn's-Algorithm-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)

![Kahn's-Algorithm-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)![Kahn's-Algorithm-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)

![Kahn's-Algorithm-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)![Kahn's-Algorithm-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)

![Kahn's-Algorithm-7.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)![Kahn's-Algorithm-7.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)

![Kahn's-Algorithm-8.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)![Kahn's-Algorithm-8.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)

![Kahn's-Algorithm-9.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)![Kahn's-Algorithm-9.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)

![Kahn's-Algorithm-10.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)![Kahn's-Algorithm-10.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)

![Kahn's-Algorithm-11.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)![Kahn's-Algorithm-11.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)

![Kahn's-Algorithm-12.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)![Kahn's-Algorithm-12.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)

![Kahn's-Algorithm-13.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)![Kahn's-Algorithm-13.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)

![Kahn's-Algorithm-14.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)![Kahn's-Algorithm-14.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240711180943/Kahn's-Algorithm-1.webp)

1 / 14 Pause

  
****Complexity Analysis:**** 

-   ****Time Complexity:**** O(V+E).   
    The outer for loop will be executed V number of times and the inner for loop will be executed E number of times.
-   ****Auxiliary Space:**** O(V).   
    The queue needs to store all the vertices of the graph. So the space required is O(V)

## ****Applications of Kahn’s algorithm for Topological Sort:****   

-   ****Course sequencing:**** Courses at universities frequently have prerequisites for other courses. The courses can be scheduled using Kahn’s algorithm so that the prerequisites are taken before the courses that call for them.
-   ****Management of software dependencies:**** When developing software, libraries and modules frequently rely on other libraries and modules. The dependencies can be installed in the proper order by using Kahn’s approach.
-   ****Scheduling tasks:**** In project management, activities frequently depend on one another. The tasks can be scheduled using Kahn’s method so that the dependent tasks are finished before the tasks that depend on them.
-   ****Data processing:**** In data processing pipelines, the outcomes of some processes may be dependent. The stages can be carried out in the right order by using Kahn’s algorithm.
-   ****Circuit design:**** In the creation of an electronic circuit, some components may be dependent on the output of others. The components can be joined in the right order by using Kahn’s technique.  
     

  

Are you looking to bridge the gap from **Data Structures and Algorithms (DSA) to Software Development**? Dive into our [**DSA to Development - Beginner to Advance Course**](https://gfgcdn.com/tu/Q8V/) on GeeksforGeeks, crafted for aspiring developers and seasoned programmers alike. Explore essential coding skills, software engineering principles, and practical application techniques through hands-on **projects** and real-world examples. Whether you're starting your journey or aiming to refine your skills, this course empowers you to build robust software solutions. Ready to advance your programming prowess? Enroll now and transform your coding capabilities!